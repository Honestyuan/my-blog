(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{546:function(t,n,e){"use strict";e.r(n);var s=e(2),r=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"_1-typeof"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-typeof"}},[t._v("#")]),t._v(" 1.typeof")]),t._v(" "),e("p",[t._v('检测基本数据类型，返回值是一个字符串（所以连续出现两个或以上的typeof时，结果都是"string"）')]),t._v(" "),e("p",[t._v('要注意的是 typeof null --\x3e "object"')]),t._v(" "),e("p",[t._v("typeof的局限性：不能具体检测object下的细分类型，比如Array,Object...")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("typeof ''; // string 有效\ntypeof 1; // number 有效\ntypeof Symbol(); // symbol 有效\ntypeof true; //boolean 有效\ntypeof undefined; //undefined 有效\ntypeof null; //object 无效\ntypeof [] ; //object 无效\ntypeof new Function(); // function 有效\ntypeof new Date(); //object 无效\ntypeof new RegExp(); //object 无效\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br")])]),e("p",[t._v("有些时候，typeof 操作符会返回一些令人迷惑但技术上却正确的值：")]),t._v(" "),e("ul",[e("li",[t._v("对于基本类型，除 null 以外，均可以返回正确的结果。")]),t._v(" "),e("li",[t._v("对于引用类型，除 function 以外，一律返回 object 类型。")]),t._v(" "),e("li",[t._v("对于 null ，返回 object 类型。")]),t._v(" "),e("li",[t._v("对于 function 返回  function 类型。")])]),t._v(" "),e("p",[t._v("其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。")]),t._v(" "),e("h2",{attrs:{id:"_2-instanceof"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-instanceof"}},[t._v("#")]),t._v(" 2.instanceof")]),t._v(" "),e("p",[t._v("检测某个对象是否是这个类的一个实例，返回值是boolean")]),t._v(" "),e("p",[e("strong",[t._v("instanceof 检测的是原型")])]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("funcction Fn() {\n    this.a=15;\n}\nvar f1=new Fn();\nconsole.log(f1 instanceof Fn); //true\nconsole.log(f1 instanceof Array); //false\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br")])]),e("p",[t._v("console.log(f1 instanceof Object); // true ，f1不仅是Fn的实例，它也是一个对象数据类型的，所以也是Object的一个实例。")]),t._v(" "),e("p",[t._v("这里涉及到类、实例的一些探讨:")]),t._v(" "),e("p",[t._v('类，是函数数据类型的 typeof Fn --\x3e "function"')]),t._v(" "),e("p",[t._v('实例，是对象数据类型的 typeof f1 --\x3e "object"')]),t._v(" "),e("p",[t._v("而函数是具有两面性的，既是函数数据类型，也是对象数据类型")]),t._v(" "),e("p",[t._v("这里要把握好对象、类、实例的概念，理解JS中万物皆对象。")]),t._v(" "),e("h2",{attrs:{id:"_3-constructor"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-constructor"}},[t._v("#")]),t._v(" 3.constructor")]),t._v(" "),e("p",[t._v("当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype上添加一个 constructor 属性，并让其指向 F 的引用。")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function F() {}\nvar f = new F()\nf,constructor == F  // true\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br")])]),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("''.constructor == String                 //true\nnew Number(1).constructor == Number      //true\ntrue.constructor == Boolean              //true\nnew Function().constructor == Function   //true\nnew Date().constructor == Date           //true\nnew Error().constructor == Error         //true\n[]..constructor == Array                 //true\ndocument.constructor == HTMLDocument     //true\nwindow.constructor == Window             //true\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br")])]),e("p",[e("strong",[t._v("细节问题：")])]),t._v(" "),e("blockquote",[e("ol",[e("li",[e("p",[t._v("null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。")])]),t._v(" "),e("li",[e("p",[t._v("函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object")])])])]),t._v(" "),e("h2",{attrs:{id:"_4-object-prototype-tostring-call"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-object-prototype-tostring-call"}},[t._v("#")]),t._v(" 4.Object.prototype.toString.call()")]),t._v(" "),e("p",[t._v("toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。")]),t._v(" "),e("p",[t._v("对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。")]),t._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("Object.prototype.toString.call('') ;   // [object String]\nObject.prototype.toString.call(1) ;    // [object Number]\nObject.prototype.toString.call(true) ; // [object Boolean]\nObject.prototype.toString.call(Symbol()); //[object Symbol]\nObject.prototype.toString.call(undefined) ; // [object Undefined]\nObject.prototype.toString.call(null) ; // [object Null]\nObject.prototype.toString.call(new Function()) ; // [object Function]\nObject.prototype.toString.call(new Date()) ; // [object Date]\nObject.prototype.toString.call([]) ; // [object Array]\nObject.prototype.toString.call(new RegExp()) ; // [object RegExp]\nObject.prototype.toString.call(new Error()) ; // [object Error]\nObject.prototype.toString.call(document) ; // [object HTMLDocument]\nObject.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用\n")])]),t._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[t._v("1")]),e("br"),e("span",{staticClass:"line-number"},[t._v("2")]),e("br"),e("span",{staticClass:"line-number"},[t._v("3")]),e("br"),e("span",{staticClass:"line-number"},[t._v("4")]),e("br"),e("span",{staticClass:"line-number"},[t._v("5")]),e("br"),e("span",{staticClass:"line-number"},[t._v("6")]),e("br"),e("span",{staticClass:"line-number"},[t._v("7")]),e("br"),e("span",{staticClass:"line-number"},[t._v("8")]),e("br"),e("span",{staticClass:"line-number"},[t._v("9")]),e("br"),e("span",{staticClass:"line-number"},[t._v("10")]),e("br"),e("span",{staticClass:"line-number"},[t._v("11")]),e("br"),e("span",{staticClass:"line-number"},[t._v("12")]),e("br"),e("span",{staticClass:"line-number"},[t._v("13")]),e("br")])])])}),[],!1,null,null,null);n.default=r.exports}}]);